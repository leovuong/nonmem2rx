---
title: "Importing NONMEM into rxode2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Importing NONMEM into rxode2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The goal of `nonmem2rx` is to convert a NONMEM control stream to
`rxode2` for easy clinical trial simulation in R.

This package is fundamentally about one thing, importing NONMEM into a
runnable `rxode2()` model

```{r setup}
library(nonmem2rx)
mod <- nonmem2rx(system.file("mods/cpt/runODE032.ctl", package="nonmem2rx"), lst=".res", save=FALSE)
mod
```


The process steps are below:

- Read in the nonmem control stream and convert the model to a
  `rxode2` ui function.

- Try to determine an endpoint in the model (if possible), and convert
  to a fully qualified ui model that can be used in `nlmixr2` and
  `rxode2` (see next section for a work-around)

- If available, `nonmem2rx` will read the final parameter estimates
  and update the model. (See below for source)

- This will read in the nonmem input dataset, and search for the
  output files with `IPRED`, `PRED` and the `ETA` values. The
  translated `rxode2` model is run for the population parameters and
  the individual parameters.  This will then compare the results
  between `NONMEM` and `rxode2` to make sure the translation makes
  sense.  This only works when `nonmem2rx` has access to the input
  data and the output with the `IWRES`, `IPRED`, `PRED` and the `ETA` values.

- Converts the upper case NONMEM variables to lower case.

- Replaces the NONMEM theta / eta names with the label-based names like an
  extended control stream.

- Replaces the compartment names with the defined compartment names in
  the control stream (ie `COMP=(compartmenName)`)
  
### Creating a nlmixr2 compatible model 

Depending on the model, not all the residual specifications are
translated to the `nlmixr2` style residuals.  This means the model
cannot be immediately used for nlmixr2 estimation (though you can
simulate with and without certainty without any modifications)

For example you could have something like:

```r
y <- ipred*(1+eps1)
```

For a model that can do `nlmixr2` estimation instead of simply
simulation the residual needs to be changed to something like:

```r
cp ~ prop(prop.sd)
```

Since the model when import has most of the translation done already,
you can easily tweak the model to have this form. 

Here is the same example where the residual errors are not
automatically translated to the `nlmixr2` parameter style (in this
case because of the option `determineError=FALSE`)



