---
title: "Importing NONMEM into rxode2"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Importing NONMEM into rxode2}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

The goal of `nonmem2rx` is to convert a NONMEM control stream to
`rxode2` for easy clinical trial simulation in R.

Here is a quick example of a conversion:

```{r model}
library(nonmem2rx)
mod <- nonmem2rx(system.file("mods/cpt/runODE032.ctl", package="nonmem2rx"), lst=".res", save=FALSE)
mod
```

## Setting up `nonmem2rx` for your model

There are a few other things you may want to do when reading in a
NONMEM control stream, which can be controlled, I believe the common ones are:

- Control the default NONMEM output extension; By default it is `.lst`
  but if you prefer something else you can set it to something
  else. For example if you use `.res` simply put
  `options(nonmem2rx.lst=".res")` at the top.
  
- Turn on or off extended control stream support. Since not everyone
  uses wings for nonmem, extended control stream support is off by
  default.  But if you wish to turn it on by default you can use
  `options(nonmem2rx.extended=TRUE)`
  
The last common task you want to probably perform is changing the names of compartments and parameters.

The easiest way to name the parameters whatever you want is to pre-specify the names.  For example:

```{r prespecify}
mod <- nonmem2rx(system.file("mods/cpt/runODE032.ctl", package="nonmem2rx"), lst=".res", save=FALSE,
                 thetaNames=c("lcl", "lvc", "lq", "lvp", "prop.sd"),
                 etaNames=c("eta.cl", "eta.vc", "eta.q","eta.vp"),
                 cmtNames = c("central", "perip"))

mod
```

This does check the parameter names to make sure they are the same
length as what is input, if are not, the model will skip parameter
renaming and keep the default translation names `theta#` and `eta#`.

As a note, `sigma` parameters are not currently renamed; So for the
following model (which grabs the parameter automatically labels to
generate variables), `sigma` is simply `eps#`.

```{r prespecifySigma}
mod <- nonmem2rx(system.file("Theopd.ctl", package="nonmem2rx"), save=FALSE)
mod
```

You can still rename however you wish, though, using model piping
(`rxRename()` or `dplyr::rename()` would both work):

```{r renameMod}
mod <- mod %>% rxRename(add.var=eps1)
mod
```

## Technical details about reading NONMEM to rxode2

The key files to import are the NONMEM control stream (or related
file) and the NONMEM output (often with a `.lst` or `.res` extension).


The import process steps are below:

- Read in the nonmem control stream and convert the model to a
  `rxode2` ui function.

- Try to determine an endpoint/residual specification in the model (if
  possible), and convert to a fully qualified ui model that can be
  used in `nlmixr2` and `rxode2` [though you can manually fix
  this](convert-nlmixr2.html)

- If available, `nonmem2rx` will read the final parameter estimates
  and update the model.

- This will read in the nonmem input dataset, and search for the
  output files with `IPRED`, `PRED` and the `ETA` values. The
  translated `rxode2` model is run for the population parameters and
  the individual parameters.  This will then compare the results
  between `NONMEM` and `rxode2` to make sure the translation makes
  sense.  This only works when `nonmem2rx` has access to the input
  data and the output with the `IWRES`, `IPRED`, `PRED` and the `ETA` values.

- Converts the upper case NONMEM variables to lower case.

- Replaces the NONMEM theta / eta names with the label-based names like an
  extended control stream.

- Replaces the compartment names with the defined compartment names in
  the control stream (ie `COMP=(compartmenName)`)
  
### Creating a nlmixr2 compatible model 

Depending on the model, not all the residual specifications are
translated to the `nlmixr2` style residuals.  This means the model
cannot be immediately used for nlmixr2 estimation (though you can
simulate with and without certainty without any modifications)

For example you could have something like:

```r
y <- ipred*(1+eps1)
```

For a model that can do `nlmixr2` estimation instead of simply
simulation the residual needs to be changed to something like:

```r
cp ~ prop(prop.sd)
```

Since the model when import has most of the translation done already,
you can easily tweak the model to have this form. 

Here is the same example where the residual errors are not
automatically translated to the `nlmixr2` parameter style (in this
case because of the option `determineError=FALSE`)



